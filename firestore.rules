/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model where each user can only access data
 * within their own user-specific document tree or data they explicitly own. Access control is based on the
 * user's authenticated UID.
 *
 * Data Structure: User-specific configuration is segregated under `/users/{userId}`. Chat data is stored in a
 * top-level `chats` collection, with ownership enforced via a `userId` field. This structure allows for
 * efficient queries on chats while maintaining strong security.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only read/write documents located under their own `/users/{userId}` path. For
 *   the `chats` collection, access is granted only if the document's `userId` field matches the requestor's UID.
 * - No Public Listing: Listing all users from the root `/users` collection is disallowed. Listing chats is
 *   only allowed for the user's own chats.
 * - Self-Creation: Authenticated users can create their own user profile document. They can also create chat
 *   and message documents, provided the ownership (`userId`) is correctly set to their own UID.
 * - Relational Integrity: On creation, key identifier fields (`user.id`, `chat.userId`, etc.) are validated
 *   against the authenticated UID to ensure data consistency. These identifiers are immutable.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function hasValidUserData_onCreate(userId) {
      let data = request.resource.data;
      return data.id == userId && data.plan == 'free';
    }

    function hasValidUserData_onUpdate() {
      // Prevent plan changes through direct client update for now
      return request.resource.data.id == resource.data.id &&
             request.resource.data.plan == resource.data.plan;
    }

    function isChatOwner(chatId) {
      return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.userId == request.auth.uid;
    }

    // Rules for /users collection
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidUserData_onCreate(userId);
      allow update: if isExistingOwner(userId) && hasValidUserData_onUpdate();
      allow delete: if isExistingOwner(userId);
    }
    
    // Rules for /chats collection
    match /chats/{chatId} {
      allow get: if isChatOwner(chatId);
      allow list: if isSignedIn(); // Query will be filtered by userId in the app
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isChatOwner(chatId); // e.g., for changing title
      allow delete: if isChatOwner(chatId);

      // Rules for messages subcollection
      match /messages/{messageId} {
        allow get: if isChatOwner(chatId);
        allow list: if isChatOwner(chatId);
        allow create: if isSignedIn() && request.resource.data.chatId == chatId;
        allow update, delete: if false; // Messages are immutable
      }
    }

    /**
     * @description Controls access to a user's session documents.
     * @path /users/{userId}/sessions/{sessionId}
     * @allow (create) An authenticated user creates a new session document for themselves. auth.uid == 'user_abc'.
     * @deny (list) An authenticated user tries to list sessions for another user. auth.uid == 'user_xyz'.
     * @principle Enforces document ownership via the parent path.
     */
    match /users/{userId}/sessions/{sessionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && hasValidSessionData_onCreate(userId, sessionId);
      allow update: if isExistingOwner(userId) && hasValidSessionData_onUpdate();
      allow delete: if isExistingOwner(userId);
    }

    function hasValidSessionData_onCreate(userId, sessionId) {
      let data = request.resource.data;
      return data.userId == userId && data.id == sessionId;
    }
    
    function hasValidSessionData_onUpdate() {
      let incomingData = request.resource.data;
      let existingData = resource.data;
      return incomingData.userId == existingData.userId && incomingData.id == existingData.id;
    }
  }
}
